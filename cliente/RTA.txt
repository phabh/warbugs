vector3df CGameCore::getQuadCenter(int linha, int coluna)
{
	vector3df center;

	center.X = (linha * TAMQUADRANTE) + (TAMQUADRANTE/2);
	center.Y = 0.0;
	center.Z = (coluna * TAMQUADRANTE) + (TAMQUADRANTE/2);

	return center;
}

//-----------------------------------------------------------------------------------------------------------------

vector3df CGameCore::getQuadCenter(int idQuad)
{
	int linha, coluna;

	getQuadLinhaColuna(idQuad, linha, coluna);

	return getQuadCenter(linha, coluna);
}

//-----------------------------------------------------------------------------------------------------------------

vector3df CGameCore::getQuadCenter(vector3df posicao)
{
	int linha, coluna;

	getQuadLinhaColuna(posicao, linha, coluna);

	return getQuadCenter(linha, coluna);
}

//-----------------------------------------------------------------------------------------------------------------

void CGameCore::getQuadLinhaColuna(vector3df posicao, int &linha, int &coluna)
{
	linha  = posicao.Z / TAMQUADRANTE; // TAMQUADRANTE é a dimensão de um quadrante em pixels
	coluna = posicao.X / TAMQUADRANTE;
}

//-----------------------------------------------------------------------------------------------------------------

void CGameCore::getQuadLinhaColuna(int idQuad, int &linha, int &coluna)
{
	linha  = idQuad / MAPMAXCOL;
	coluna = idQuad % MAPMAXCOL;
}

//-----------------------------------------------------------------------------------------------------------------

int CGameCore::getQuadID(vector3df posicao)
{
	int linha, coluna;

	getQuadLinhaColuna(posicao, linha, coluna);

	return getQuadID(linha, coluna);
}

//-----------------------------------------------------------------------------------------------------------------

int CGameCore::getQuadID(int linha, int coluna)
{
	return ( coluna + (linha * MAPMAXCOL) );
}





        int manhattan(int linhaO, int colunaO, int linhaD, int colunaD)
        {
            int deltaL, deltaC;

            deltaL = abs(linhaD - linhaO);
            deltaC = abs(colunaD - colunaO);

            return deltaL + deltaC;
        }


        int pathfindingRTA(CPersonagem *personagem)
        {

			vector3df origem = personagem->_posicao;
			vector3df destino = personagem->_destino;

		    int direcaoProximoPasso = -1;

            int idQuadSucessor = -1;

			int idQuadOrigem  = getQuadID(origem);
			int idQuadDestino = getQuadID(destino);

            int melhorVizinho1 = -1;
            int melhorVizinho2 = -1;

            int lin_o, col_o, lin_d, col_d;

            int custoFuncao[8];

            int custoVizinho, menorCusto1, menorCusto2;

            menorCusto1 = 9999999;
            menorCusto2 = 9999999;

		  int custoAdjacencia = 0;

		  
			getQuadLinhaColuna(idQuadDestino, lin_d, col_d);

            for (int i = 0; i < 8; i++)
            {

				getQuadLinhaColuna(idQuadOrigem, lin_o, col_o);
				
                
                switch (i)
                {
                    default:
                    case 0: col_o +=  0; lin_o +=  1; custoAdjacencia = 1; break;  // Norte
                    case 1: col_o +=  1; lin_o +=  1; custoAdjacencia = 2; break;  // Nordeste
                    case 2: col_o +=  1; lin_o +=  0; custoAdjacencia = 1; break;  // Leste
                    case 3: col_o +=  1; lin_o += -1; custoAdjacencia = 2; break;  // Sudeste
                    case 4: col_o +=  0; lin_o += -1; custoAdjacencia = 1; break;  // Sul
                    case 5: col_o += -1; lin_o += -1; custoAdjacencia = 2; break;  // Sudoeste
                    case 6: col_o += -1; lin_o +=  0; custoAdjacencia = 1; break;  // Oeste
                    case 7: col_o += -1; lin_o +=  1; custoAdjacencia = 2; break;  // Noroeste
                }

                if (_cenario[lin_o][col_o].isPassable)
                {
                        idQuadSucessor = getQuadID(lin_o, col_o); // pega indice do quadrante vizinho  
                        
                        Folha lembranca = personagem->memoria.busca(idQuadSucessor); // procura na memória o indice do sucessor

                        if (lembranca == NULL)
                            custoFuncao[i] = manhattan(lin_o, col_o, lin_d, col_d) + custoAdjacencia;
                        else
                            custoFuncao[i] = lembranca.heuristica + custoAdjacencia;


                        if (custoFuncao[i] < menorCusto1)
                        {
                            melhorVizinho2 = melhorVizinho1;
                            menorCusto2 = menorCusto1; // atualiza o segundo menor

                            melhorVizinho1 = idQuadSucessor;
                            menorCusto1 = custoFuncao[i];
                            direcaoProximoPasso = i;
						}

                }
                else
                    custoFuncao[i] = 9999999;
            }

            if (melhorVizinho2 == -1) // se teve apenas uma opção de movimento, segundo menor = menor de todos
            {
                melhorVizinho2 = melhorVizinho1;
                menorCusto2 = menorCusto1;
            }
            
            if (melhorVizinho2 != -1) // se teve alguma opção de movimento
                personagem->memoria.guardar(idQuadOrigem, menorCusto2);

			if(idQuadDestino == melhorVizinho1)
				personagem->memoria.clear();

            return direcaoProximoPasso;
        }
    }
}
